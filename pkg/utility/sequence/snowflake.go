package sequence

import (
	"sync"
	"time"
)

const (
	timestampBits   = uint(41)
	workerBits      = uint(5)
	datacenterBits  = uint(5)
	sequenceBits    = uint(12)
	sequenceMask    = uint64(-1 ^ (-1 << sequenceBits))
	workeridShift   = sequenceBits
	datacenterShift = sequenceBits + workerBits
	timestampShift  = sequenceBits + workerBits + datacenterBits
)

// Snowflake algorithm implementation
type Snowflake struct {
	sync.Mutex
	epoch        uint64
	timestamp    uint64
	workerID     uint64
	datacenterID uint64
	sequence     uint64
}

// NewSnowflake create a new Snowflake algorithm
func NewSnowflake(epoch, workerID uint64) (snowflake *Snowflake) {
	return &Snowflake{
		epoch:        epoch,
		timestamp:    uint64(0),
		workerID:     workerID,
		datacenterID: uint64(1),
		sequence:     uint64(0),
	}
}

// Next implementa the Sequence interface
func (flake *Snowflake) Next() (seq uint64) {
	flake.Lock()
	now := time.Now().UnixNano() / 1e9
	if flake.timestamp == uint64(now) {
		flake.sequence = (flake.sequence + 1) & uint64(sequenceMask)
		if flake.sequence == 0 {
			// If the ID generated by the current working node
			// within 1 millisecond has exceeded the upper limit
			// you need to wait for 1 millisecond before continuing to generate
			for now <= int64(flake.timestamp) {
				// nanoseconds to milliseconds
				now = time.Now().UnixNano() / 1e9
			}
		}
	} else {
		// If the current time is inconsistent with the time
		// when the worker node generated the ID last time
		// you need to reset the ID number of the worker node
		flake.sequence = 0
	}
	t := now - int64(flake.epoch)
	flake.timestamp = uint64(now)
	seq = uint64(
		(t << int64(timestampShift)) |
			(int64(flake.datacenterID) << int64(datacenterShift)) |
			(int64(flake.workerID) << int64(workeridShift)) |
			int64(flake.sequence))
	flake.Unlock()
	return
}
